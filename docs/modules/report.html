<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>modules.report API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>modules.report</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from enum import Enum
from os import mkdir

from modules.stix.stix import Stix
from utils.validation import Validator, rec_search_key
from utils import output
from datetime import datetime
from os.path import sep
from utils.logger import Logger
from requests.structures import CaseInsensitiveDict
from jinja2 import Environment, FileSystemLoader
from pathlib import Path
from utils.globals import version
from distutils.dir_util import copy_tree as cp
from utils.prune import pruner
from pprint import pformat


class Report:
    &#34;&#34;&#34;
    Output Module that generates the report.

    &#34;&#34;&#34;

    class Mode(Enum):
        &#34;&#34;&#34;
        Enum for the report mode.
        &#34;&#34;&#34;

        HOSTS = 0
        MODULES = 1

    def __init__(self):
        self.__input_dict = {}
        self.__path = &#34;&#34;
        self.__template_dir = Path(f&#34;configs{sep}out_template&#34;)
        self.__logging = Logger(&#34;Report&#34;)

    def input(self, **kwargs):
        &#34;&#34;&#34;
        Input function for the Report module.
        :param kwargs: Arguments for the Report module. See below.
        :type kwargs: dict

        :Keyword Arguments:
        * *results* (dict) -- Dictionary containing the results of the scan.
        * *path* (string) -- Path to the report.
        * *mode* (Mode) -- Report mode.
        * *stix* (bool) -- If True, the report will be in STIX format.
        &#34;&#34;&#34;
        self.__input_dict = kwargs

    def __modules_report_formatter(self, results: dict, modules: list) -&gt; dict:
        &#34;&#34;&#34;
        Formats the results of the modules.

        :param results: Dictionary containing the results of the scan.
        :type results: dict
        :param modules: List of modules to include in the report.
        :type modules: list
        :return: Dictionary containing the results of the scan.
        :rtype: dict
        &#34;&#34;&#34;
        out = {}
        for module in modules:
            vuln_hosts = []
            raw_results = {}
            if module not in out:
                out[module] = {}
            for hostname in results:
                self.__logging.debug(f&#34;Generating report for {hostname}&#34;)
                if module in results[hostname]:
                    if &#34;raw&#34; in results[hostname][module]:
                        raw_results[hostname] = results[hostname][module][&#34;raw&#34;].copy()
                    if &#34;Entry&#34; in results[hostname][module]:
                        out[module] = CaseInsensitiveDict(
                            results[hostname][module][&#34;Entry&#34;]
                        )
                    if hostname not in vuln_hosts:
                        vuln_hosts.append(hostname)
            if raw_results:
                out[module][&#34;raw&#34;] = pformat(raw_results.copy(), indent=2)
            if vuln_hosts:
                out[module][&#34;hosts&#34;] = vuln_hosts.copy()
            if not out[module]:
                del out[module]
        return out

    def __hosts_report_formatter(self, results: dict) -&gt; dict:
        &#34;&#34;&#34;
        Formats the results of the hosts.

        :param results: Dictionary containing the results of the scan.
        :type results: dict
        :return: Dictionary containing the results of the scan.
        :rtype: dict
        &#34;&#34;&#34;
        out = {}
        for hostname in results:
            # the results are good, we need to remove the &#34;Entry&#34; key but preserve the rest with the CaseInsensitiveDict
            if hostname not in out:
                out[hostname] = {}
            for module in results[hostname]:
                raw_results = {}
                if &#34;raw&#34; in results[hostname][module]:
                    raw_results = results[hostname][module][&#34;raw&#34;].copy()
                if &#34;Entry&#34; in results[hostname][module]:
                    out[hostname][module] = CaseInsensitiveDict(
                        results[hostname][module][&#34;Entry&#34;]
                    )
                    if raw_results:
                        out[hostname][module][&#34;raw&#34;] = pformat(
                            raw_results.copy(), indent=2
                        )
        return out

    def __jinja2__report(
        self, mode: Mode, results: dict, modules: list, date: datetime.date
    ):
        &#34;&#34;&#34;
        Generates the report using jinja2.

        :param mode: Report mode.
        :type mode: Mode
        :param results: Dictionary containing the results of the scan.
        :type results: dict
        :param modules: List of modules to include in the report.
        :type modules: list
        :param date: Date of the scan.
        :type date: datetime.date
        &#34;&#34;&#34;
        self.__logging.debug(f&#34;Generating report in jinja2..&#34;)
        fsl = FileSystemLoader(searchpath=self.__template_dir)
        env = Environment(loader=fsl)
        to_process = {&#34;version&#34;: version, &#34;date&#34;: date, &#34;modules&#34;: modules}
        if mode == self.Mode.MODULES:
            self.__logging.info(f&#34;Generating modules report..&#34;)
            template = env.get_template(f&#34;modules_report.html&#34;)
            to_process[&#34;results&#34;] = self.__modules_report_formatter(results, modules)
        elif mode == self.Mode.HOSTS:
            self.__logging.info(f&#34;Generating hosts report..&#34;)
            template = env.get_template(f&#34;hosts_report.html&#34;)
            to_process[&#34;results&#34;] = self.__hosts_report_formatter(results)
        else:
            raise ValueError(f&#34;Unknown mode: {mode}&#34;)
        return template.render(**to_process)

    def __extract_results(self, res: dict) -&gt; tuple:
        &#34;&#34;&#34;
        Extracts the results from the input dictionary.

        :param res: Input dictionary.
        :type res: dict
        :return: Tuple containing the results and the modules.
        :rtype: tuple
        &#34;&#34;&#34;
        # due to the fact that the results are in a dict with the loaded_modules, we have to extract the results
        # by removing the loaded_modules
        modules = {}
        for hostname in res:
            if &#34;loaded_modules&#34; in res[hostname]:
                modules.update(res[hostname][&#34;loaded_modules&#34;].copy())
                del res[hostname][&#34;loaded_modules&#34;]
                res[hostname] = res[hostname][&#34;results&#34;]
        return res, modules

    def run(self, **kwargs):
        &#34;&#34;&#34;
        Runs the report.

        :param kwargs: Arguments for the Report module. See below.
        :type kwargs: dict

        :Keyword Arguments:
        * *results* (dict) -- Dictionary containing the results of the scan.
        * *path* (string) -- Path to the report.
        * *mode* (Mode) -- Report mode.
        * *stix* (bool) -- If True, the report will be generated in STIX format.
        &#34;&#34;&#34;

        self.input(**kwargs)
        assert &#34;path&#34; in self.__input_dict, &#34;Missing output path&#34;
        assert &#34;results&#34; in self.__input_dict, &#34;Missing results list&#34;
        assert &#34;mode&#34; in self.__input_dict, &#34;Missing mode&#34;
        assert &#34;stix&#34; in self.__input_dict, &#34;Missing stix flag&#34;

        path = self.__input_dict[&#34;path&#34;]
        self.__path = Path(path)

        Validator(
            [
                (path, str),
                (self.__input_dict[&#34;results&#34;], dict),
                (self.__input_dict[&#34;mode&#34;], self.Mode),
                (self.__input_dict[&#34;stix&#34;], bool),
            ]
        )

        if not Path(&#34;results&#34;).exists():
            self.__logging.debug(&#34;Adding result folder...&#34;)
            mkdir(&#34;results&#34;)
        if not Path(f&#34;results{sep}assets&#34;).exists():
            self.__logging.debug(&#34;Copying assets folder...&#34;)
            cp(
                str(Path(f&#34;configs{sep}out_template{sep}assets&#34;).absolute()),
                str(Path(f&#34;results{sep}assets&#34;).absolute()),
            )

        output_file = Path(f&#34;results{sep}{self.__path.stem}.html&#34;)
        output_path = output_file.absolute()
        results, modules = self.__extract_results(
            self.__input_dict[&#34;results&#34;]
        )  # obtain results removing loaded_modules
        results = pruner(results)  # prune empty results
        # now, we want to divide raw from mitigations
        for hostname in results:
            for module in results[hostname]:
                raw = results[hostname][module].copy()
                if &#34;mitigation&#34; in raw:
                    del raw[&#34;mitigation&#34;]
                for mitigation in rec_search_key(
                    &#34;mitigation&#34;, results[hostname][module]
                ):
                    if mitigation is not None:
                        results[hostname][
                            module
                        ] = (
                            mitigation.copy()
                        )  # i&#39;m expecting only one mitigation per module, is it ok?
                results[hostname][module][&#34;raw&#34;] = raw
        with open(output_path, &#34;w&#34;) as f:
            f.write(
                self.__jinja2__report(
                    mode=self.__input_dict[&#34;mode&#34;],
                    modules=list(modules.keys()),
                    results=results,
                    date=datetime.now().replace(microsecond=0),
                )
            )
        self.__logging.debug(&#34;Checking if needs pdf...&#34;)

        if self.__path.suffix.lower() == &#34;.pdf&#34;:
            output_path = f&#34;{output_file.absolute().parent}{sep}{output_file.stem}.pdf&#34;
            self.__logging.debug(&#34;Starting HTML to PDF...&#34;)
            output.html_to_pdf(str(output_file.absolute()), output_path)
        self.__logging.info(f&#34;Report generated at {output_path}&#34;)

        self.__logging.debug(&#34;Checks if needs stix...&#34;)

        if &#34;stix&#34; in self.__input_dict and self.__input_dict[&#34;stix&#34;]:
            stix_output_path = Path(
                f&#34;{output_file.absolute().parent}{sep}stix_{output_file.stem}.json&#34;
            ).absolute()
            results_to_stix = (
                self.__hosts_report_formatter(results)
                if self.__input_dict[&#34;mode&#34;] == self.Mode.HOSTS
                else self.__modules_report_formatter(results, modules)
            )
            self.__logging.info(&#34;Starting STIX generation...&#34;)
            Stix(type_of_analysis=self.__input_dict[&#34;mode&#34;].value).build_and_save(
                results_to_stix, modules, str(stix_output_path)
            )

    # todo: add PDF library</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="modules.report.Report"><code class="flex name class">
<span>class <span class="ident">Report</span></span>
</code></dt>
<dd>
<div class="desc"><p>Output Module that generates the report.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Report:
    &#34;&#34;&#34;
    Output Module that generates the report.

    &#34;&#34;&#34;

    class Mode(Enum):
        &#34;&#34;&#34;
        Enum for the report mode.
        &#34;&#34;&#34;

        HOSTS = 0
        MODULES = 1

    def __init__(self):
        self.__input_dict = {}
        self.__path = &#34;&#34;
        self.__template_dir = Path(f&#34;configs{sep}out_template&#34;)
        self.__logging = Logger(&#34;Report&#34;)

    def input(self, **kwargs):
        &#34;&#34;&#34;
        Input function for the Report module.
        :param kwargs: Arguments for the Report module. See below.
        :type kwargs: dict

        :Keyword Arguments:
        * *results* (dict) -- Dictionary containing the results of the scan.
        * *path* (string) -- Path to the report.
        * *mode* (Mode) -- Report mode.
        * *stix* (bool) -- If True, the report will be in STIX format.
        &#34;&#34;&#34;
        self.__input_dict = kwargs

    def __modules_report_formatter(self, results: dict, modules: list) -&gt; dict:
        &#34;&#34;&#34;
        Formats the results of the modules.

        :param results: Dictionary containing the results of the scan.
        :type results: dict
        :param modules: List of modules to include in the report.
        :type modules: list
        :return: Dictionary containing the results of the scan.
        :rtype: dict
        &#34;&#34;&#34;
        out = {}
        for module in modules:
            vuln_hosts = []
            raw_results = {}
            if module not in out:
                out[module] = {}
            for hostname in results:
                self.__logging.debug(f&#34;Generating report for {hostname}&#34;)
                if module in results[hostname]:
                    if &#34;raw&#34; in results[hostname][module]:
                        raw_results[hostname] = results[hostname][module][&#34;raw&#34;].copy()
                    if &#34;Entry&#34; in results[hostname][module]:
                        out[module] = CaseInsensitiveDict(
                            results[hostname][module][&#34;Entry&#34;]
                        )
                    if hostname not in vuln_hosts:
                        vuln_hosts.append(hostname)
            if raw_results:
                out[module][&#34;raw&#34;] = pformat(raw_results.copy(), indent=2)
            if vuln_hosts:
                out[module][&#34;hosts&#34;] = vuln_hosts.copy()
            if not out[module]:
                del out[module]
        return out

    def __hosts_report_formatter(self, results: dict) -&gt; dict:
        &#34;&#34;&#34;
        Formats the results of the hosts.

        :param results: Dictionary containing the results of the scan.
        :type results: dict
        :return: Dictionary containing the results of the scan.
        :rtype: dict
        &#34;&#34;&#34;
        out = {}
        for hostname in results:
            # the results are good, we need to remove the &#34;Entry&#34; key but preserve the rest with the CaseInsensitiveDict
            if hostname not in out:
                out[hostname] = {}
            for module in results[hostname]:
                raw_results = {}
                if &#34;raw&#34; in results[hostname][module]:
                    raw_results = results[hostname][module][&#34;raw&#34;].copy()
                if &#34;Entry&#34; in results[hostname][module]:
                    out[hostname][module] = CaseInsensitiveDict(
                        results[hostname][module][&#34;Entry&#34;]
                    )
                    if raw_results:
                        out[hostname][module][&#34;raw&#34;] = pformat(
                            raw_results.copy(), indent=2
                        )
        return out

    def __jinja2__report(
        self, mode: Mode, results: dict, modules: list, date: datetime.date
    ):
        &#34;&#34;&#34;
        Generates the report using jinja2.

        :param mode: Report mode.
        :type mode: Mode
        :param results: Dictionary containing the results of the scan.
        :type results: dict
        :param modules: List of modules to include in the report.
        :type modules: list
        :param date: Date of the scan.
        :type date: datetime.date
        &#34;&#34;&#34;
        self.__logging.debug(f&#34;Generating report in jinja2..&#34;)
        fsl = FileSystemLoader(searchpath=self.__template_dir)
        env = Environment(loader=fsl)
        to_process = {&#34;version&#34;: version, &#34;date&#34;: date, &#34;modules&#34;: modules}
        if mode == self.Mode.MODULES:
            self.__logging.info(f&#34;Generating modules report..&#34;)
            template = env.get_template(f&#34;modules_report.html&#34;)
            to_process[&#34;results&#34;] = self.__modules_report_formatter(results, modules)
        elif mode == self.Mode.HOSTS:
            self.__logging.info(f&#34;Generating hosts report..&#34;)
            template = env.get_template(f&#34;hosts_report.html&#34;)
            to_process[&#34;results&#34;] = self.__hosts_report_formatter(results)
        else:
            raise ValueError(f&#34;Unknown mode: {mode}&#34;)
        return template.render(**to_process)

    def __extract_results(self, res: dict) -&gt; tuple:
        &#34;&#34;&#34;
        Extracts the results from the input dictionary.

        :param res: Input dictionary.
        :type res: dict
        :return: Tuple containing the results and the modules.
        :rtype: tuple
        &#34;&#34;&#34;
        # due to the fact that the results are in a dict with the loaded_modules, we have to extract the results
        # by removing the loaded_modules
        modules = {}
        for hostname in res:
            if &#34;loaded_modules&#34; in res[hostname]:
                modules.update(res[hostname][&#34;loaded_modules&#34;].copy())
                del res[hostname][&#34;loaded_modules&#34;]
                res[hostname] = res[hostname][&#34;results&#34;]
        return res, modules

    def run(self, **kwargs):
        &#34;&#34;&#34;
        Runs the report.

        :param kwargs: Arguments for the Report module. See below.
        :type kwargs: dict

        :Keyword Arguments:
        * *results* (dict) -- Dictionary containing the results of the scan.
        * *path* (string) -- Path to the report.
        * *mode* (Mode) -- Report mode.
        * *stix* (bool) -- If True, the report will be generated in STIX format.
        &#34;&#34;&#34;

        self.input(**kwargs)
        assert &#34;path&#34; in self.__input_dict, &#34;Missing output path&#34;
        assert &#34;results&#34; in self.__input_dict, &#34;Missing results list&#34;
        assert &#34;mode&#34; in self.__input_dict, &#34;Missing mode&#34;
        assert &#34;stix&#34; in self.__input_dict, &#34;Missing stix flag&#34;

        path = self.__input_dict[&#34;path&#34;]
        self.__path = Path(path)

        Validator(
            [
                (path, str),
                (self.__input_dict[&#34;results&#34;], dict),
                (self.__input_dict[&#34;mode&#34;], self.Mode),
                (self.__input_dict[&#34;stix&#34;], bool),
            ]
        )

        if not Path(&#34;results&#34;).exists():
            self.__logging.debug(&#34;Adding result folder...&#34;)
            mkdir(&#34;results&#34;)
        if not Path(f&#34;results{sep}assets&#34;).exists():
            self.__logging.debug(&#34;Copying assets folder...&#34;)
            cp(
                str(Path(f&#34;configs{sep}out_template{sep}assets&#34;).absolute()),
                str(Path(f&#34;results{sep}assets&#34;).absolute()),
            )

        output_file = Path(f&#34;results{sep}{self.__path.stem}.html&#34;)
        output_path = output_file.absolute()
        results, modules = self.__extract_results(
            self.__input_dict[&#34;results&#34;]
        )  # obtain results removing loaded_modules
        results = pruner(results)  # prune empty results
        # now, we want to divide raw from mitigations
        for hostname in results:
            for module in results[hostname]:
                raw = results[hostname][module].copy()
                if &#34;mitigation&#34; in raw:
                    del raw[&#34;mitigation&#34;]
                for mitigation in rec_search_key(
                    &#34;mitigation&#34;, results[hostname][module]
                ):
                    if mitigation is not None:
                        results[hostname][
                            module
                        ] = (
                            mitigation.copy()
                        )  # i&#39;m expecting only one mitigation per module, is it ok?
                results[hostname][module][&#34;raw&#34;] = raw
        with open(output_path, &#34;w&#34;) as f:
            f.write(
                self.__jinja2__report(
                    mode=self.__input_dict[&#34;mode&#34;],
                    modules=list(modules.keys()),
                    results=results,
                    date=datetime.now().replace(microsecond=0),
                )
            )
        self.__logging.debug(&#34;Checking if needs pdf...&#34;)

        if self.__path.suffix.lower() == &#34;.pdf&#34;:
            output_path = f&#34;{output_file.absolute().parent}{sep}{output_file.stem}.pdf&#34;
            self.__logging.debug(&#34;Starting HTML to PDF...&#34;)
            output.html_to_pdf(str(output_file.absolute()), output_path)
        self.__logging.info(f&#34;Report generated at {output_path}&#34;)

        self.__logging.debug(&#34;Checks if needs stix...&#34;)

        if &#34;stix&#34; in self.__input_dict and self.__input_dict[&#34;stix&#34;]:
            stix_output_path = Path(
                f&#34;{output_file.absolute().parent}{sep}stix_{output_file.stem}.json&#34;
            ).absolute()
            results_to_stix = (
                self.__hosts_report_formatter(results)
                if self.__input_dict[&#34;mode&#34;] == self.Mode.HOSTS
                else self.__modules_report_formatter(results, modules)
            )
            self.__logging.info(&#34;Starting STIX generation...&#34;)
            Stix(type_of_analysis=self.__input_dict[&#34;mode&#34;].value).build_and_save(
                results_to_stix, modules, str(stix_output_path)
            )

    # todo: add PDF library</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="modules.report.Report.Mode"><code class="name">var <span class="ident">Mode</span></code></dt>
<dd>
<div class="desc"><p>Enum for the report mode.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="modules.report.Report.input"><code class="name flex">
<span>def <span class="ident">input</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Input function for the Report module.
:param kwargs: Arguments for the Report module. See below.
:type kwargs: dict</p>
<p>:Keyword Arguments:
* <em>results</em> (dict) &ndash; Dictionary containing the results of the scan.
* <em>path</em> (string) &ndash; Path to the report.
* <em>mode</em> (Mode) &ndash; Report mode.
* <em>stix</em> (bool) &ndash; If True, the report will be in STIX format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def input(self, **kwargs):
    &#34;&#34;&#34;
    Input function for the Report module.
    :param kwargs: Arguments for the Report module. See below.
    :type kwargs: dict

    :Keyword Arguments:
    * *results* (dict) -- Dictionary containing the results of the scan.
    * *path* (string) -- Path to the report.
    * *mode* (Mode) -- Report mode.
    * *stix* (bool) -- If True, the report will be in STIX format.
    &#34;&#34;&#34;
    self.__input_dict = kwargs</code></pre>
</details>
</dd>
<dt id="modules.report.Report.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the report.</p>
<p>:param kwargs: Arguments for the Report module. See below.
:type kwargs: dict</p>
<p>:Keyword Arguments:
* <em>results</em> (dict) &ndash; Dictionary containing the results of the scan.
* <em>path</em> (string) &ndash; Path to the report.
* <em>mode</em> (Mode) &ndash; Report mode.
* <em>stix</em> (bool) &ndash; If True, the report will be generated in STIX format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, **kwargs):
    &#34;&#34;&#34;
    Runs the report.

    :param kwargs: Arguments for the Report module. See below.
    :type kwargs: dict

    :Keyword Arguments:
    * *results* (dict) -- Dictionary containing the results of the scan.
    * *path* (string) -- Path to the report.
    * *mode* (Mode) -- Report mode.
    * *stix* (bool) -- If True, the report will be generated in STIX format.
    &#34;&#34;&#34;

    self.input(**kwargs)
    assert &#34;path&#34; in self.__input_dict, &#34;Missing output path&#34;
    assert &#34;results&#34; in self.__input_dict, &#34;Missing results list&#34;
    assert &#34;mode&#34; in self.__input_dict, &#34;Missing mode&#34;
    assert &#34;stix&#34; in self.__input_dict, &#34;Missing stix flag&#34;

    path = self.__input_dict[&#34;path&#34;]
    self.__path = Path(path)

    Validator(
        [
            (path, str),
            (self.__input_dict[&#34;results&#34;], dict),
            (self.__input_dict[&#34;mode&#34;], self.Mode),
            (self.__input_dict[&#34;stix&#34;], bool),
        ]
    )

    if not Path(&#34;results&#34;).exists():
        self.__logging.debug(&#34;Adding result folder...&#34;)
        mkdir(&#34;results&#34;)
    if not Path(f&#34;results{sep}assets&#34;).exists():
        self.__logging.debug(&#34;Copying assets folder...&#34;)
        cp(
            str(Path(f&#34;configs{sep}out_template{sep}assets&#34;).absolute()),
            str(Path(f&#34;results{sep}assets&#34;).absolute()),
        )

    output_file = Path(f&#34;results{sep}{self.__path.stem}.html&#34;)
    output_path = output_file.absolute()
    results, modules = self.__extract_results(
        self.__input_dict[&#34;results&#34;]
    )  # obtain results removing loaded_modules
    results = pruner(results)  # prune empty results
    # now, we want to divide raw from mitigations
    for hostname in results:
        for module in results[hostname]:
            raw = results[hostname][module].copy()
            if &#34;mitigation&#34; in raw:
                del raw[&#34;mitigation&#34;]
            for mitigation in rec_search_key(
                &#34;mitigation&#34;, results[hostname][module]
            ):
                if mitigation is not None:
                    results[hostname][
                        module
                    ] = (
                        mitigation.copy()
                    )  # i&#39;m expecting only one mitigation per module, is it ok?
            results[hostname][module][&#34;raw&#34;] = raw
    with open(output_path, &#34;w&#34;) as f:
        f.write(
            self.__jinja2__report(
                mode=self.__input_dict[&#34;mode&#34;],
                modules=list(modules.keys()),
                results=results,
                date=datetime.now().replace(microsecond=0),
            )
        )
    self.__logging.debug(&#34;Checking if needs pdf...&#34;)

    if self.__path.suffix.lower() == &#34;.pdf&#34;:
        output_path = f&#34;{output_file.absolute().parent}{sep}{output_file.stem}.pdf&#34;
        self.__logging.debug(&#34;Starting HTML to PDF...&#34;)
        output.html_to_pdf(str(output_file.absolute()), output_path)
    self.__logging.info(f&#34;Report generated at {output_path}&#34;)

    self.__logging.debug(&#34;Checks if needs stix...&#34;)

    if &#34;stix&#34; in self.__input_dict and self.__input_dict[&#34;stix&#34;]:
        stix_output_path = Path(
            f&#34;{output_file.absolute().parent}{sep}stix_{output_file.stem}.json&#34;
        ).absolute()
        results_to_stix = (
            self.__hosts_report_formatter(results)
            if self.__input_dict[&#34;mode&#34;] == self.Mode.HOSTS
            else self.__modules_report_formatter(results, modules)
        )
        self.__logging.info(&#34;Starting STIX generation...&#34;)
        Stix(type_of_analysis=self.__input_dict[&#34;mode&#34;].value).build_and_save(
            results_to_stix, modules, str(stix_output_path)
        )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="modules" href="index.html">modules</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="modules.report.Report" href="#modules.report.Report">Report</a></code></h4>
<ul class="">
<li><code><a title="modules.report.Report.Mode" href="#modules.report.Report.Mode">Mode</a></code></li>
<li><code><a title="modules.report.Report.input" href="#modules.report.Report.input">input</a></code></li>
<li><code><a title="modules.report.Report.run" href="#modules.report.Report.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>